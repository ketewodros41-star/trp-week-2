import logging
from langgraph.graph import StateGraph, START, END
from src.state import AgentState, Evidence
from src.nodes.detectives import (
    context_builder_node,
    repo_investigator_node,
    doc_analyst_node,
    vision_inspector_node,
    evidence_aggregator_node,
)
from src.nodes.judges import (
    prosecutor_node,
    defense_node,
    tech_lead_node,
    judicial_aggregator_node,
)
from src.nodes.justice import chief_justice_node
import json
import argparse
import os
from dotenv import load_dotenv

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Error-Handling Nodes
# ---------------------------------------------------------------------------

def failure_handler_node(state: AgentState) -> dict:
    """
    Graceful failure handler: logs and reports when a critical node fails.
    Produces a minimal Evidence set so downstream judges have something to evaluate.
    """
    evidences = state.get("evidences", {})
    logger.error("[FailureHandler] A critical error state was detected. Building fallback evidence.")

    # Ensure at least minimal evidence exists for all expected keys
    fallback_keys = [
        "git_forensic_analysis", "state_management_rigor", "graph_orchestration",
        "safe_tool_engineering", "structured_output_enforcement",
    ]
    for key in fallback_keys:
        if key not in evidences:
            evidences[key] = [Evidence(
                goal=f"Fallback evidence for '{key}' (failure path)",
                found=False,
                location="N/A — node failure",
                rationale="A critical node failed. This fallback evidence was generated by the failure handler.",
                confidence=0.0,
            )]

    return {"evidences": evidences}


def judge_error_handler_node(state: AgentState) -> dict:
    """
    Handles malformed or missing judge output. If the opinions list is empty
    or corrupted after judicial fan-in, this node generates fallback opinions.
    """
    from src.state import JudicialOpinion
    from src.nodes.judges import FALLBACK_MESSAGES

    opinions = state.get("opinions", [])
    dimensions = state.get("rubric_dimensions", [])

    logger.error(
        f"[JudgeErrorHandler] Triggered. {len(opinions)} opinions present, checking validity."
    )

    # Ensure every dimension has at least one opinion per judge
    expected_judges = ["Prosecutor", "Defense", "TechLead"]
    for dim in dimensions:
        dim_id = dim["id"]
        for judge_name in expected_judges:
            has_opinion = any(
                o.criterion_id == dim_id and o.judge == judge_name for o in opinions
            )
            if not has_opinion:
                fallback_arg = FALLBACK_MESSAGES.get(
                    judge_name, f"Graph-level error recovery for {judge_name}."
                )
                opinions.append(
                    JudicialOpinion(
                        judge=judge_name,
                        criterion_id=dim_id,
                        score=1,
                        argument=fallback_arg,
                        cited_evidence=[],
                    )
                )

    return {"opinions": opinions}


# ---------------------------------------------------------------------------
# Routers (Conditional Edge Functions)
# ---------------------------------------------------------------------------

def detective_router(state: AgentState):
    """Router for conditional parallel fan-out based on available artifacts."""
    available = state.get("available_artifacts", [])
    targets = []

    if "repo" in available:
        targets.append("repo_investigator")
    if "pdf" in available:
        targets.append("doc_analyst")
        targets.append("vision_inspector")

    # If no artifacts are found, route to failure handler
    if not targets:
        return "failure_handler"
    return targets


def evidence_quality_router(state: AgentState):
    """
    Post-aggregation router: checks if evidence is sufficient to proceed
    to judicial layer, or if error handling is needed.
    """
    evidences = state.get("evidences", {})

    # Check for minimum viable evidence
    total_evidence_items = sum(len(v) for v in evidences.values())
    found_items = sum(1 for vals in evidences.values() for e in vals if e.found)

    if total_evidence_items == 0:
        logger.warning("[Router] No evidence collected. Routing to failure handler.")
        return "failure_handler"

    if found_items == 0:
        logger.warning("[Router] All evidence marks found=False. Routing to failure handler.")
        return "failure_handler"

    # Sufficient evidence — proceed to judicial fan-out
    return ["prosecutor", "defense", "tech_lead"]


def judicial_quality_router(state: AgentState):
    """
    Post-judicial router: checks if judge opinions are valid before synthesis.
    Routes to error handler if opinions are malformed or missing.
    """
    opinions = state.get("opinions", [])
    dimensions = state.get("rubric_dimensions", [])

    if not opinions:
        logger.warning("[Router] No judicial opinions present. Routing to error handler.")
        return "judge_error_handler"

    # Check that we have at least one opinion per dimension
    dim_ids = {d["id"] for d in dimensions}
    covered_dims = {o.criterion_id for o in opinions}
    missing_dims = dim_ids - covered_dims

    if len(missing_dims) > len(dim_ids) // 2:
        logger.warning(f"[Router] Majority of dimensions missing opinions: {missing_dims}. Routing to error handler.")
        return "judge_error_handler"

    return "chief_justice"


# ---------------------------------------------------------------------------
# Graph Builder
# ---------------------------------------------------------------------------

def create_graph():
    workflow = StateGraph(AgentState)

    # --- Add all nodes ---
    workflow.add_node("context_builder", context_builder_node)
    workflow.add_node("repo_investigator", repo_investigator_node)
    workflow.add_node("doc_analyst", doc_analyst_node)
    workflow.add_node("vision_inspector", vision_inspector_node)
    workflow.add_node("evidence_aggregator", evidence_aggregator_node)

    # Error-handling nodes
    workflow.add_node("failure_handler", failure_handler_node)
    workflow.add_node("judge_error_handler", judge_error_handler_node)

    workflow.add_node("prosecutor", prosecutor_node)
    workflow.add_node("defense", defense_node)
    workflow.add_node("tech_lead", tech_lead_node)
    workflow.add_node("judicial_aggregator", judicial_aggregator_node)

    workflow.add_node("chief_justice", chief_justice_node)

    # =======================================================================
    # ORCHESTRATION LAYER 1: Forensic Phase (Detective Fan-Out / Fan-In)
    # =======================================================================
    workflow.add_edge(START, "context_builder")

    # Conditional fan-out: routes to available detectives or failure_handler
    workflow.add_conditional_edges(
        "context_builder",
        detective_router,
        {
            "repo_investigator": "repo_investigator",
            "doc_analyst": "doc_analyst",
            "vision_inspector": "vision_inspector",
            "failure_handler": "failure_handler",
        }
    )

    # Fan-In: All detectives converge on evidence aggregator
    workflow.add_edge("repo_investigator", "evidence_aggregator")
    workflow.add_edge("doc_analyst", "evidence_aggregator")
    workflow.add_edge("vision_inspector", "evidence_aggregator")

    # Failure handler also routes to aggregator (with fallback evidence)
    workflow.add_edge("failure_handler", "evidence_aggregator")

    # =======================================================================
    # ORCHESTRATION LAYER 2: Judicial Phase (Judge Fan-Out / Fan-In)
    # =======================================================================

    # Post-aggregation quality check before dispatching to judges
    workflow.add_conditional_edges(
        "evidence_aggregator",
        evidence_quality_router,
        {
            "prosecutor": "prosecutor",
            "defense": "defense",
            "tech_lead": "tech_lead",
            "failure_handler": "failure_handler",
        }
    )

    # Fan-In: All judges converge on the dedicated judicial aggregator
    workflow.add_edge("prosecutor", "judicial_aggregator")
    workflow.add_edge("defense", "judicial_aggregator")
    workflow.add_edge("tech_lead", "judicial_aggregator")

    # Post-judicial quality check before synthesis
    workflow.add_conditional_edges(
        "judicial_aggregator",
        judicial_quality_router,
        {
            "chief_justice": "chief_justice",
            "judge_error_handler": "judge_error_handler",
        }
    )

    # Error handler feeds into chief justice (with patched opinions)
    workflow.add_edge("judge_error_handler", "chief_justice")

    # =======================================================================
    # TERMINAL
    # =======================================================================
    workflow.add_edge("chief_justice", END)

    return workflow.compile()


def main():
    load_dotenv()

    parser = argparse.ArgumentParser(
        description="Automaton Auditor: Run the Digital Courtroom swarm against a target repo."
    )
    parser.add_argument(
        "--repo-url",
        required=True,
        help="GitHub repository URL to audit (e.g. https://github.com/user/repo)",
    )
    parser.add_argument(
        "--pdf-path",
        required=True,
        help="Path to the architectural PDF report to audit",
    )
    parser.add_argument(
        "--rubric",
        default="rubric.json",
        help="Path to rubric JSON file (default: rubric.json)",
    )
    parser.add_argument(
        "--output-dir",
        default="audit/report_onself_generated",
        help="Output directory for the generated Markdown report",
    )
    args = parser.parse_args()

    with open(args.rubric, "r") as f:
        rubric = json.load(f)

    app = create_graph()

    initial_state = {
        "repo_url": args.repo_url,
        "pdf_path": args.pdf_path,
        "rubric_dimensions": rubric["dimensions"],
        "available_artifacts": [],
        "evidences": {},
        "opinions": [],
        "final_report": None,
    }

    # Override the output directory used by ChiefJustice
    os.environ["AUDIT_OUTPUT_DIR"] = args.output_dir

    print(f"[Auditor] Starting audit of: {args.repo_url}")
    print(f"[Auditor] PDF Report: {args.pdf_path}")
    print(f"[Auditor] Output: {args.output_dir}/report.md")
    print("[Auditor] LangSmith tracing:", os.getenv("LANGCHAIN_TRACING_V2", "false"))

    for event in app.stream(initial_state):
        for node_name, output in event.items():
            print(f"[Auditor] Node '{node_name}' finished.")

    print(f"\n[Auditor] ✅ Audit complete. Report saved to: {args.output_dir}/report.md")


if __name__ == "__main__":
    main()
